# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:126
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
appliance\ vm[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = appliance vm[uuid:{0}] is in status of {1} that cannot make http call to {2}

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:97
# args: spec.getRequiredBackupStorageUuid(),bsType
the\ backup\ storage[uuid\:%s,\ type\:%s]\ requires\ bound\ primary\ storage,\ however,\ the\ primary\ storage\ has\ not\ been\ added = the backup storage[uuid:{0}, type:{1}] requires bound primary storage, however, the primary storage has not been added

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:90
# args: spec.getImage().getUuid(),spec.getRequiredBackupStorageUuid(),type,psUuids
The\ image[uuid\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[uuids\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = The image[uuid:{0}] is on the backup storage[uuid:{1}, type:{2}] that requires to work with primary storage[uuids:{3}],however, no host found suitable to work with those primary storage

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:80
# args: spec.getImage().getUuid(),spec.getRequiredBackupStorageUuid(),type,possiblePrimaryStorageTypes
The\ image[uuid\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[types\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = The image[uuid:{0}] is on the backup storage[uuid:{1}, type:{2}] that requires to work with primary storage[types:{3}],however, no host found suitable to work with those primary storage

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:85
# args: spec.getImage().getUuid(),spec.getImage().getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ deleted\ on\ all\ backup\ storage = the image[uuid:{0}, name:{1}] is deleted on all backup storage

# at: src/main/java/org/zstack/compute/host/HostBase.java:104
# args: self.getUuid(),self.getName(),self.getState()
host[uuid\:%s,\ name\:%s]\ is\ in\ state[%s],\ cannot\ perform\ required\ operation = host[uuid:{0}, name:{1}] is in state[{2}], cannot perform required operation

# at: src/main/java/org/zstack/compute/host/HostBase.java:566
# args: 
host\ is\ connecting = host is connecting

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:275
# args: vo.getName(),vo.getManagementIp()
after\ connecting,\ host[name\:%s,\ ip\:%s]\ returns\ a\ null\ os\ version = after connecting, host[name:{0}, ip:{1}] returns a null os version

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:314
# args: vo.getClusterUuid(),currentVersion,vo.getName(),vo.getManagementIp(),mineVersion
cluster[uuid\:%s]\ already\ has\ host\ with\ os\ version[%s],\ but\ new\ added\ host[name\:%s\ ip\:%s]\ has\ host\ os\ version[%s] = cluster[uuid:{0}] already has host with os version[{1}], but new added host[name:{2} ip:{3}] has host os version[{4}]

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:50
# args: 
not\ dest\ host\ found\ in\ db,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = not dest host found in db, can't send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:51
# args: 
not\ system\ tag\ found\ on\ vm,\ vm\ must\ have\ the\ following\ system\ tag\:\ qemuga,\ if\ you\ installed\ qemu-ga\ yourself,\ please\ use\ CreateSystemTag\ first. = not system tag found on vm, vm must have the following system tag: qemuga, if you installed qemu-ga yourself, please use CreateSystemTag first.

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:54
# args: 
not\ account\ preference\ found,\ \ send\ change\ password\ cmd\ to\ the\ host! = not account preference found,  send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/DeleteVmGC.java:43
# args: hostUuid
the\ host[uuid\:%s]\ is\ not\ connected = the host[uuid:{0}] is not connected

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:497
# args: amsg.getVmInstanceUuid()
not\ dest\ host\ found\ in\ db\ by\ uuid\:\ %s,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = not dest host found in db by uuid: {0}, can't send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:518
# args: 
state\ is\ not\ correct\ while\ change\ password. = state is not correct while change password.

# at: src/main/java/org/zstack/compute/vm/VmDownloadIsoFlow.java:64
# args: iso.getUuid(),host.getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ iso[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ running\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the iso[uuid:{0}] in any connected backup storage attached to the zone[uuid:{1}]. check below:\
1. if the backup storage is attached to the zone where the VM[name: {2}, uuid:{3}] is running\
2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:85
# args: imageUuid,spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage.\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the image[uuid:{0}] in any connected backup storage. check below:\
1. if the backup storage is attached to the zone where the VM[name: {1}, uuid:{2}] is in\
2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:79
# args: imageUuid,spec.getVmInventory().getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the image[uuid:{0}] in any connected backup storage attached to the zone[uuid:{1}]. check below:\
1. if the backup storage is attached to the zone where the VM[name: {2}, uuid:{3}] is in\
2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:107
# args: zoneUuid,isoImageUuid
no\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s]\ contains\ the\ ISO[uuid\:%s] = no backup storage attached to the zone[uuid:{0}] contains the ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:180
# args: msg.getVmInstanceUuid()
vm[uuid\:%s]\ can\ only\ create\ scheduler\ when\ state\ is\ not\ Destroyed = vm[uuid:{0}] can only create scheduler when state is not Destroyed

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:231
# args: msg.getVmInstanceUuid(),isoUuid
VM[uuid\:%s]\ already\ has\ an\ ISO[uuid\:%s]\ attached = VM[uuid:{0}] already has an ISO[uuid:{1}] attached

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:243
# args: type
unable\ to\ attach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ a\ user\ vm = unable to attach a L3 network. The vm[uuid: {0}] is not a user vm

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:315
# args: msg.getVmInstanceUuid(),state
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = unable to detach a L3 network. The vm[uuid: {0}] is not Running or Stopped; the current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:255
# args: msg.getL3NetworkUuid(),msg.getVmInstanceUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = unable to attach a L3 network. The L3 network[uuid:{0}] is already attached to the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:266
# args: msg.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ disabled = unable to attach a L3 network. The L3 network[uuid:{0}] is disabled

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:269
# args: msg.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ a\ system\ network = unable to attach a L3 network. The L3 network[uuid:{0}] is a system network

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:295
# args: msg.getStaticIp(),msg.getL3NetworkUuid()
the\ static\ IP[%s]\ has\ been\ occupied\ on\ the\ L3\ network[uuid\:%s] = the static IP[{0}] has been occupied on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:311
# args: msg.getVmInstanceUuid()
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ a\ user\ vm = unable to detach a L3 network. The vm[uuid: {0}] is not a user vm

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:339
# args: msg.getVmInstanceUuid(),state
vm[uuid\:%s]\ can\ only\ attach\ volume\ when\ state\ is\ Running\ or\ Stopped,\ current\ state\ is\ %s = vm[uuid:{0}] can only attach volume when state is Running or Stopped, current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:349
# args: msg.getInstanceOfferingUuid()
instance\ offering[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = instance offering[uuid:{0}] is Disabled, can't create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:358
# args: msg.getImageUuid()
image[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = image[uuid:{0}] is Disabled, can't create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:398
# args: diskUuids
disk\ offerings[uuids\:%s]\ are\ Disabled,\ can\ not\ create\ vm\ from\ it = disk offerings[uuids:{0}] are Disabled, can not create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:407
# args: duplicateElements.get(0)
Can't\ add\ same\ uuid\ in\ the\ l3Network,uuid\:\ %s = Can't add same uuid in the l3Network,uuid: {0}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:417
# args: l3Uuid
l3Network[uuid\:%s]\ is\ Disabled,\ can\ not\ create\ vm\ on\ it = l3Network[uuid:{0}] is Disabled, can not create vm on it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:421
# args: l3Uuid
l3Network[uuid\:%s]\ is\ system\ network,\ can\ not\ create\ user\ vm\ on\ it = l3Network[uuid:{0}] is system network, can not create user vm on it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:439
# args: msg.getZoneUuid()
zone[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = zone[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:449
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = cluster[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:460
# args: msg.getHostUuid()
host[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = host[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:465
# args: msg.getHostUuid(),connectionState
host[uuid\:%s]\ is\ specified\ but\ it's\ connection\ status\ is\ %s,\ can\ not\ create\ vm\ from\ it = host[uuid:{0}] is specified but it's connection status is {1}, can not create vm from it

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:221
# args: vo.getUuid(),vo.getName()
vm[uuid\:%s,\ name\:%s]\ has\ been\ deleted = vm[uuid:{0}, name:{1}] has been deleted

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:529
# args: self.getUuid(),l3Uuid
the\ vm[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = the vm[uuid:{0}] has no nic on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:877
# args: 
the\ vm\ has\ been\ deleted = the vm has been deleted

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:1214
# args: 
cannot\ get\ target\ migration\ host\ without\ any\ nics\ on\ vm = cannot get target migration host without any nics on vm

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:2869
# args: isoUuid,psUuid,self.getName(),self.getUuid()
the\ ISO[uuid\:%s]\ is\ on\ backup\ storage\ that\ is\ not\ compatible\ of\ the\ primary\ storage[uuid\:%s]\ where\ the\ VM[name\:%s,\ uuid\:%s]\ is\ on = the ISO[uuid:{0}] is on backup storage that is not compatible of the primary storage[uuid:{1}] where the VM[name:{2}, uuid:{3}] is on

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3085
# args: self.getUuid(),self.getState(),StringUtils.join(list(VmInstanceState.Running, VmInstanceState.Stopped), ",")
The\ state\ of\ vm[uuid\:%s]\ is\ %s.\ Only\ these\ state[%s]\ is\ allowed. = The state of vm[uuid:{0}] is {1}. Only these state[{2}] is allowed.

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3680
# args: self.getUuid()
unable\ to\ start\ the\ vm[uuid\:%s].\ It\ doesn't\ have\ any\ nic,\ please\ attach\ a\ nic\ and\ try\ again = unable to start the vm[uuid:{0}]. It doesn't have any nic, please attach a nic and try again

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:41
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartNewCreatedVmExtensionPoint[%s]\ refuses\ to\ create\ vm[uuid\:%s]\ because\ %s = VmInstanceStartNewCreatedVmExtensionPoint[{0}] refuses to create vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:83
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStopVmExtensionPoint[%s]\ refuses\ to\ stop\ vm[uuid\:%s]\ because\ %s = VmInstanceStopVmExtensionPoint[{0}] refuses to stop vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:125
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceRebootExtensionPoint[%s]\ refuses\ to\ reboot\ vm[uuid\:%s]\ because\ %s = VmInstanceRebootExtensionPoint[{0}] refuses to reboot vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:167
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceDestroyVmExtensionPoint[%s]\ refuses\ to\ destroy\ vm[uuid\:%s]\ because\ %s = VmInstanceDestroyVmExtensionPoint[{0}] refuses to destroy vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:208
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartExtensionPoint[%s]\ refuses\ to\ start\ vm[uuid\:%s]\ because\ %s = VmInstanceStartExtensionPoint[{0}] refuses to start vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:940
# args: ip,l3Uuid
IP[%s]\ is\ not\ available\ on\ the\ L3\ network[uuid\:%s] = IP[{0}] is not available on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1959
# args: ref.getResourceUuid()
the\ resource[uuid\:%s]\ is\ a\ ROOT\ volume,\ you\ cannot\ change\ its\ owner,\ instead,change\ the\ owner\ of\ the\ VM\ the\ root\ volume\ belongs\ to = the resource[uuid:{0}] is a ROOT volume, you cannot change its owner, instead,change the owner of the VM the root volume belongs to

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:101
# args: 
the\ console\ agent\ is\ not\ connected;\ it's\ mostly\ like\ the\ management\ node\ just\ starts,\ please\ wait\ for\ the\ console\ agent\ connected. = the console agent is not connected; it's mostly like the management node just starts, please wait for the console agent connected.

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:122
# args: vm.getUuid()
cannot\ find\ host\ IP\ of\ the\ vm[uuid\:%s],\ is\ the\ vm\ running??? = cannot find host IP of the vm[uuid:{0}], is the vm running???

# at: src/main/java/org/zstack/console/ConsoleApiInterceptor.java:48
# args: msg.getVmInstanceUuid(),state
Console\ is\ only\ available\ when\ the\ VM[uuid\:%s]\ is\ Running,\ but\ the\ current\ state\ is\ %s = Console is only available when the VM[uuid:{0}] is Running, but the current state is {1}

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:140
# args: ret.getError()
unable\ to\ check\ console\ proxy\ availability,\ because\ %s = unable to check console proxy availability, because {0}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:107
# args: srcFolder,srcRes.getStdout(),srcRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s].\nstdout\:%s\nstderr\:%s = cannot check md5sum of files in the folder[{0}].\nstdout:{1}\nstderr:{2}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:122
# args: dstFolder,hostname,dstRes.getStdout(),dstRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s]\ on\ the\ host[ip\:%s].\nstdout\:%s\nstderr\:%s = cannot check md5sum of files in the folder[{0}] on the host[ip:{1}].\nstdout:{2}\nstderr:{3}

# at: src/main/java/org/zstack/core/gc/GarbageCollectorManagerImpl.java:210
# args: vo.getUuid(),vo.getName()
cannot\ trigger\ a\ finished\ GC\ job[uuid\:%s,\ name\:%s] = cannot trigger a finished GC job[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/core/progress/ProgressReportService.java:92
# args: processType
not\ supported\ processType\:\ %s = not supported processType: {0}

# at: src/main/java/org/zstack/core/progress/ProgressReportService.java:100
# args: uuid
not\ supported\ null\ uuid\:\ %s = not supported null uuid: {0}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:454
# args: url,rsp.getStatusCode(),rsp.getBody()
failed\ to\ post\ to\ %s,\ status\ code\:\ %s,\ response\ body\:\ %s = failed to post to {0}, status code: {1}, response body: {2}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:495
# args: url,timeout
unable\ to\ echo\ %s\ in\ %sms = unable to echo {0} in {1}ms

# at: src/main/java/org/zstack/core/salt/SaltRunner.java:297
# args: stateName,targetIp,retry
failed\ to\ run\ salt\ state[%s]\ on\ system[%s],\ failed\ after\ %s\ retries = failed to run salt state[{0}] on system[{1}], failed after {2} retries

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:79
# args: 
can\ not\ enable\ a\ Enabled\ scheduler = can not enable a Enabled scheduler

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:82
# args: 
can\ not\ disable\ a\ Disabled\ scheduler = can not disable a Disabled scheduler

# at: src/main/java/org/zstack/ha/HaKvmHostSiblingChecker.java:153
# args: struct.getHostUuid(),struct.getHostIp(),errors
hosts\ failed\ to\ port\ scan\ the\ failure\ host[uuid\:%s,\ ip\:%s],\ errors\ are\ %s = hosts failed to port scan the failure host[uuid:{0}, ip:{1}], errors are {2}

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:63
# args: self.getName(),self.getUuid()
cannot\ find\ the\ host\ of\ the\ vm[name\:%s,\ uuid\:%s],\ hostUuid\ is\ null = cannot find the host of the vm[name:{0}, uuid:{1}], hostUuid is null

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:70
# args: 
no\ HaHostChecker\ found,\ cannot\ do\ HA = no HaHostChecker found, cannot do HA

# at: src/main/java/org/zstack/ha/HaManagementNodeChecker.java:46
# args: 
the\ management\ node\ fails\ to\ scan\ the\ host = the management node fails to scan the host

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:339
# args: msg.getUserUuid()
the\ user\ specified\ by\ the\ userUuid[%s]\ does\ not\ belong\ to\ the\ current\ account,\ and\ the\ current\ account\ is\ not\ an\ admin\ account,\ so\ it\ has\ no\ permission\ to\ check\ the\ user'spermissions = the user specified by the userUuid[{0}] does not belong to the current account, and the current account is not an admin account, so it has no permission to check the user'spermissions

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1717
# args: 
the\ name\ of\ admin\ account\ cannot\ be\ updated = the name of admin account cannot be updated

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1727
# args: account.getUuid(),account.getName(),msg.getUuid()
account[uuid\:\ %s,\ name\:\ %s]\ is\ a\ normal\ account,\ it\ cannot\ reset\ the\ password\ of\ another\ account[uuid\:\ %s] = account[uuid: {0}, name: {1}] is a normal account, it cannot reset the password of another account[uuid: {2}]

# at: src/main/java/org/zstack/image/BackupStorageDeleteBitGC.java:35
# args: backupStorageUuid,bsStatus
the\ backup\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = the backup storage[uuid:{0}] is not in status of Connected, current status is {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:74
# args: vol.getUuid(),vol.getStatus()
volume[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = volume[uuid:{0}] is not Ready, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:78
# args: vol.getUuid(),vol.getState()
volume[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = volume[uuid:{0}] is not Enabled, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:87
# args: vol.getUuid(),vol.getVmInstanceUuid(),state
volume[uuid\:%s]\ is\ attached\ to\ vm[uuid\:%s];\ the\ vm\ is\ not\ Stopped,\ it's\ %s = volume[uuid:{0}] is attached to vm[uuid:{1}]; the vm is not Stopped, it's {2}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:154
# args: msg.getBackupStorageUuids(),BackupStorageStatus.Connected,BackupStorageState.Enabled
no\ backup\ storage\ specified\ in\ uuids%s\ is\ available\ for\ adding\ this\ image;\ they\ are\ not\ in\ status\ %s\ or\ not\ in\ state\ %s,\ or\ the\ uuid\ is\ invalid\ backup\ storage\ uuid = no backup storage specified in uuids{0} is available for adding this image; they are not in status {1} or not in state {2}, or the uuid is invalid backup storage uuid

# at: src/main/java/org/zstack/image/ImageBase.java:146
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ any\ backup\ storage = the image[uuid:{0}, name:{1}] is not on any backup storage

# at: src/main/java/org/zstack/image/ImageBase.java:156
# args: self.getUuid(),self.getName()
No\ connected\ backup\ storage\ found\ for\ image[uuid\:%s,\ name\:%s] = No connected backup storage found for image[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/image/ImageBase.java:518
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ any\ backup\ storage = the image[uuid:{0}, name:{1}] is not deleted on any backup storage

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:286
# args: msg.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
failed\ to\ allocate\ all\ backup\ storage[uuid\:%s],\ a\ list\ of\ error\:\ %s = failed to allocate all backup storage[uuid:{0}], a list of error: {1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:695
# args: msg.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids%s,\ list\ errors\ are\:\ %s = unable to allocate backup storage specified by uuids{0}, list errors are: {1}

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:88
# args: msg.getL3NetworkUuid()
the\ L3\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = the L3 network[uuid:{0}] doesn't have any IP range

# at: src/main/java/org/zstack/kvm/KVMConnectExtensionForL2Network.java:125
# args: l2.getType()
KVMConnectExtensionForL2Network\ wont's\ support\ L2Network[type\:%s] = KVMConnectExtensionForL2Network wont's support L2Network[type:{0}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:414
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),result.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort:%d ] to do DNS check, please check if username/password is wrong; {2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:486
# args: self.getUuid(),self.getStatus()
the\ host[uuid\:%s,\ status\:%s]\ is\ not\ Connected = the host[uuid:{0}, status:{1}] is not Connected

# at: src/main/java/org/zstack/kvm/KVMHost.java:861
# args: volume.getUuid(),state
cannot\ do\ volume\ snapshot\ merge\ when\ vm[uuid\:%s]\ is\ in\ state\ of\ %s.\ The\ operation\ is\ only\ allowed\ when\ vm\ is\ Running\ or\ Stopped = cannot do volume snapshot merge when vm[uuid:{0}] is in state of {1}. The operation is only allowed when vm is Running or Stopped

# at: src/main/java/org/zstack/kvm/KVMHost.java:868
# args: KVMConstant.MIN_LIBVIRT_LIVE_BLOCK_COMMIT_VERSION,libvirtVersion
live\ volume\ snapshot\ merge\ needs\ libvirt\ version\ greater\ than\ %s,\ current\ libvirt\ version\ is\ %s.\ Please\ stop\ vm\ and\ redo\ the\ operation\ or\ detach\ the\ volume\ if\ it's\ data\ volume = live volume snapshot merge needs libvirt version greater than {0}, current libvirt version is {1}. Please stop vm and redo the operation or detach the volume if it's data volume

# at: src/main/java/org/zstack/kvm/KVMHost.java:943
# args: msg.getVmUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state[%s] = vm[uuid:{0}] is not Running or Stopped, current state[{1}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:1328
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ detach\ data\ volume[uuid\:%s,\ installPath\:%s]\ from\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to detach data volume[uuid:{0}, installPath:{1}] from vm[uuid:{2}, name:{3}] on kvm host[uuid:{4}, ip:{5}], because {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1424
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ attach\ data\ volume[uuid\:%s,\ installPath\:%s]\ to\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to attach data volume[uuid:{0}, installPath:{1}] to vm[uuid:{2}, name:{3}] on kvm host[uuid:{4}, ip:{5}], because {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1482
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ destroy\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to destroy vm[uuid:{0} name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1648
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ stop\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to stop vm[uuid:{0} name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1886
# args: spec.getVmInventory().getUuid(),spec.getVmInventory().getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ start\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to start vm[uuid:{0} name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2126
# args: rsp.getError(),msg.getPhysicalInterface(),context.getInventory().getUuid(),context.getInventory().getManagementIp()
%s,\ failed\ to\ check\ physical\ network\ interfaces[names\ \:\ %s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s] = {0}, failed to check physical network interfaces[names : {1}] on kvm host[uuid:{2}, ip:{3}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:2305
# args: self.getUuid(),self.getManagementIp(),connectPath,rsp.getError()
unable\ to\ connect\ to\ kvm\ host[uuid\:%s,\ ip\:%s,\ url\:%s],\ because\ %s = unable to connect to kvm host[uuid:{0}, ip:{1}, url:{2}], because {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2445
# args: checkList
failed\ to\ ping\ all\ DNS/IP\ in\ %s;\ please\ check\ /etc/resolv.conf\ to\ make\ sure\ your\ host\ is\ able\ to\ reach\ public\ internet = failed to ping all DNS/IP in {0}; please check /etc/resolv.conf to make sure your host is able to reach public internet

# at: src/main/java/org/zstack/kvm/KVMHost.java:2443
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:\ %d,\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort: %d, ] to do DNS check, please check if username/password is wrong; {2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2473
# args: self.getManagementIp(),Platform.getManagementServerIp(),ret.getStderr(),ret.getExitErrorMessage()
the\ KVM\ host[ip\:%s]\ cannot\ access\ the\ management\ node's\ callback\ url.\ It\ seems\ that\ the\ KVM\ host\ cannot\ reach\ the\ management\ IP[%s].\ %s\ %s = the KVM host[ip:{0}] cannot access the management node's callback url. It seems that the KVM host cannot reach the management IP[{1}]. {2} {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2470
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d]\ to\ check\ the\ management\ node\ connectivity,please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort:%d] to check the management node connectivity,please check if username/password is wrong; {2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2564
# args: self.getUuid(),self.getManagementIp(),ret.getExecutionLog()
unable\ to\ get\ kvm\ host[uuid\:%s,\ ip\:%s]\ facts\ by\ ansible\n%s = unable to get kvm host[uuid:{0}, ip:{1}] facts by ansible\n{2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2570
# args: ret.getStdout()
unrecognized\ ansible\ facts\ mediaType,\ %s = unrecognized ansible facts mediaType, {0}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2577
# args: ret.getStdout()
unrecognized\ ansible\ facts\ mediaType,\ cannot\ find\ field\ 'ansible_facts',\ %s = unrecognized ansible facts mediaType, cannot find field 'ansible_facts', {0}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2608
# args: 
cannot\ find\ either\ 'vmx'\ or\ 'svm'\ in\ /proc/cpuinfo,\ please\ make\ sure\ you\ have\ enabled\ virtualization\ in\ your\ BIOS\ setting = cannot find either 'vmx' or 'svm' in /proc/cpuinfo, please make sure you have enabled virtualization in your BIOS setting

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:69
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for l2Network[uuid:{1}, type:{2}] on kvm host[uuid:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:120
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2NoVlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:\ %s],\ %s = failed to check bridge[{0}] for l2NoVlanNetwork[uuid:{1}, name:{2}] on kvm host[uuid: {3}], {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:72
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vlan.getVlan(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vlan\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for l2Network[uuid:{1}, type:{2}, vlan:{3}] on kvm host[uuid:{4}], because {5}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:124
# args: cmd.getBridgeName(),l2vlan.getUuid(),l2vlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2VlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = failed to check bridge[{0}] for l2VlanNetwork[uuid:{1}, name:{2}] on kvm host[uuid:{3}], {4}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:97
# args: hto.getHostUuid(),rsp.getError()
failed\ to\ apply\ rules\ of\ security\ group\ rules\ to\ kvm\ host[uuid\:%s],\ because\ %s = failed to apply rules of security group rules to kvm host[uuid:{0}], because {1}

# at: src/main/java/org/zstack/kvm/KvmVmSyncPingTask.java:90
# args: host.getUuid(),host.getManagementIp(),ret.getError()
unable\ to\ do\ vm\ sync\ on\ host[uuid\:%s,\ ip\:%s]\ because\ %s = unable to do vm sync on host[uuid:{0}, ip:{1}] because {2}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:155
# args: getLicenseType(),getHostNumAllowedByLicense(),hostnum
hijacked\ host\ number\ detected.\ Your\ license[%s]\ permits\ %s\ hosts,\ but\ we\ detect\ there\ are\ %s\ hosts\ in\ the\ database.\ You\ can\ either\ delete\ additional\ hosts\ or\ apply\ a\ new\ license = hijacked host number detected. Your license[{0}] permits {1} hosts, but we detect there are {2} hosts in the database. You can either delete additional hosts or apply a new license

# at: src/main/java/org/zstack/mediator/ApiValidator.java:94
# args: vm.getName(),vm.getUuid(),StringUtils.join(pfStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ port\ forwarding\ rules%s\ attached = the vm[name:{0}, uuid:{1}] already has some port forwarding rules{2} attached

# at: src/main/java/org/zstack/mediator/ApiValidator.java:115
# args: vm.getName(),vm.getUuid(),StringUtils.join(eipStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ EIPs%s\ attached = the vm[name:{0}, uuid:{1}] already has some EIPs{2} attached

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:222
# args: psType
for\ shareable\ volume,\ the\ only\ supported\ primary\ storage\ type\ is\ ceph,\ current\ is\ %s = for shareable volume, the only supported primary storage type is ceph, current is {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:503
# args: hostUuid,distro,version
the\ host[uuid\:%s]'s\ operating\ system\ %s\ %s\ is\ too\ old,\ the\ QEMU\ doesn't\ support\ QoS\ of\ network\ or\ disk\ IO.\ Please\ choose\ another\ instance\ offering\ with\ no\ QoS\ configuration = the host[uuid:{0}]'s operating system {1} {2} is too old, the QEMU doesn't support QoS of network or disk IO. Please choose another instance offering with no QoS configuration

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1390
# args: volume.getUuid(),vm.getUuid()
Shareable\ Volume[uuid\:%s]\ has\ already\ been\ attached\ to\ VM[uuid\:%s] = Shareable Volume[uuid:{0}] has already been attached to VM[uuid:{1}]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1408
# args: 
shareable\ disk\ only\ support\ virtio-scsi\ type\ for\ now = shareable disk only support virtio-scsi type for now

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:245
# args: msg.getVolume().getUuid(),msg.getVmInstanceUuid()
failed\ to\ detach\ shareable\ volume[uuid\:%s]\ from\ VmInstance[uuid\:%s] = failed to detach shareable volume[uuid:{0}] from VmInstance[uuid:{1}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:257
# args: StringUtils.join(errors, "\n\n")
failed\ to\ detach\ shareable\ volume\ from\ VmInstance\:[\n%s] = failed to detach shareable volume from VmInstance:[\n{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:308
# args: msg.getDns(),msg.getL3NetworkUuid()
there\ has\ been\ a\ DNS[%s]\ on\ L3\ network[uuid\:%s] = there has been a DNS[{0}] on L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:100
# args: type,msg.getL3NetworkUuid()
there\ has\ been\ a\ network\ service[%s]\ attached\ to\ L3\ network[uuid\:%s] = there has been a network service[{0}] attached to L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/service/NetworkServiceManagerImpl.java:369
# args: l3NetworkUuid,serviceType
L3Network[uuid\:%s]\ doesn't\ have\ network\ service[type\:%s]\ enabled\ or\ no\ provider\ provides\ this\ network\ service = L3Network[uuid:{0}] doesn't have network service[type:{1}] enabled or no provider provides this network service

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:78
# args: msg.getEipUuid()
eip[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ cannot\ get\ attachable\ vm\ nic = eip[uuid:{0}] is not in state of Enabled, cannot get attachable vm nic

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:83
# args: msg.getEipUuid(),vmNicUuid
eip[uuid\:%s]\ has\ attached\ to\ vm\ nic[uuid\:%s],\ cannot\ get\ attachable\ vm\ nic = eip[uuid:{0}] has attached to vm nic[uuid:{1}], cannot get attachable vm nic

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:103
# args: msg.getEipUuid(),EipState.Enabled,state
eip[uuid\:\ %s]\ can\ only\ be\ attached\ when\ state\ is\ %s,\ current\ state\ is\ %s = eip[uuid: {0}] can only be attached when state is {1}, current state is {2}

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:165
# args: eipIp,gw,netmask,vmNicUuid
overlap\ public\ and\ private\ subnets.\ The\ subnet\ of\ EIP[%s]\ is\ an\ overlap\ with\ the\ subnet[%s/%s]\ of\ the\ VM\ nic[uuid\:%s]. = overlap public and private subnets. The subnet of EIP[{0}] is an overlap with the subnet[{1}/{2}] of the VM nic[uuid:{3}].

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:1076
# args: l3.getUuid(),l3.getName(),vm.getUuid(),vm.getName()
unable\ to\ attach\ the\ L3\ network[uuid\:%s,\ name\:%s]\ to\ the\ vm[uuid\:%s,\ name\:%s],\ because\ the\ L3\ network\ is\ providing\ EIP\ to\ one\ of\ the\ vm's\ nic = unable to attach the L3 network[uuid:{0}, name:{1}] to the vm[uuid:{2}, name:{3}], because the L3 network is providing EIP to one of the vm's nic

# at: src/main/java/org/zstack/network/service/flat/FlatEipBackend.java:529
# args: vmUuid,vm.getState()
unable\ to\ apply\ the\ EIP\ operation\ for\ the\ the\ vm[uuid\:%s,\ state\:%s],\ because\ cannot\ find\ the\ VM's\ hostUUid = unable to apply the EIP operation for the the vm[uuid:{0}, state:{1}], because cannot find the VM's hostUUid

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:125
# args: l3Uuid,LoadBalancerConstants.LB_NETWORK_SERVICE_TYPE_STRING
the\ L3\ network[uuid\:%s]\ of\ the\ vm\ nics\ has\ no\ network\ service[%s]\ enabled = the L3 network[uuid:{0}] of the vm nics has no network service[{1}] enabled

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:134
# args: existingNics,msg.getListenerUuid()
the\ vm\ nics[uuid\:%s]\ are\ already\ on\ the\ load\ balancer\ listener[uuid\:%s] = the vm nics[uuid:{0}] are already on the load balancer listener[uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:902
# args: msg.getVmNicUuids().get(0)
the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ doesn't\ have\ load\ balancer\ service\ enabled = the L3 network of vm nic[uuid:{0}] doesn't have load balancer service enabled

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:929
# args: self.getUuid(),self.getProviderType(),msg.getVmNicUuids().get(0),providerType
service\ provider\ type\ mismatching.\ The\ load\ balancer[uuid\:%s]\ is\ provided\ by\ the\ service\ provider[type\:%s],\ but\ the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ is\ enabled\ with\ the\ service\ provider[type\:\ %s] = service provider type mismatching. The load balancer[uuid:{0}] is provided by the service provider[type:{1}], but the L3 network of vm nic[uuid:{2}] is enabled with the service provider[type: {3}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:91
# args: msg.getLoadBalancerUuid()
cannot\ find\ the\ load\ balancer[uuid\:%s] = cannot find the load balancer[uuid:{0}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:230
# args: tag.getTag()
cannot\ delete\ the\ system\ tag[%s].\ The\ load\ balancer\ plugin\ relies\ on\ it,\ you\ can\ only\ update\ it = cannot delete the system tag[{0}]. The load balancer plugin relies on it, you can only update it

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:64
# args: msg.getRuleUuid(),state
Port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ current\ state\ is\ %s = Port forwarding rule[uuid:{0}] is not in state of Enabled, current state is {1}

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:69
# args: msg.getRuleUuid(),vmNicUuid
Port\ forwarding\ rule[uuid\:%s]\ has\ been\ attached\ to\ vm\ nic[uuid\:%s]\ already = Port forwarding rule[uuid:{0}] has been attached to vm nic[uuid:{1}] already

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:100
# args: msg.getRuleUuid(),state
port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ \ current\ state\ is\ %s.\ A\ rule\ can\ only\ be\ attached\ when\ its\ state\ is\ Enabled = port forwarding rule[uuid:{0}] is not in state of Enabled,  current state is {1}. A rule can only be attached when its state is Enabled

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:242
# args: vm.getName(),vm.getUuid(),vipUuid
the\ VM[name\:%s\ uuid\:%s]\ already\ has\ port\ forwarding\ rules\ that\ have\ different\ VIPs\ than\ the\ one[uuid\:%s] = the VM[name:{0} uuid:{1}] already has port forwarding rules that have different VIPs than the one[uuid:{2}]

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:65
# args: msg.getRequiredIp(),msg.getL3NetworkUuid()
there\ is\ already\ a\ vip[%s]\ on\ l3Network[uuid\:%s] = there is already a vip[{0}] on l3Network[uuid:{1}]

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:179
# args: self.getUuid(),self.getName(),self.getIp(),self.getServiceProvider()
service\ provider\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = service provider of the vip[uuid:{0}, name:{1}, ip: {2}] has been set to {3}

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:189
# args: self.getUuid(),self.getName(),self.getIp(),self.getUseFor()
the\ field\ 'useFor'\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = the field 'useFor' of the vip[uuid:{0}, name:{1}, ip: {2}] has been set to {3}

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:199
# args: self.getUuid(),self.getName(),self.getIp(),self.getPeerL3NetworkUuid()
the\ field\ 'peerL3NetworkUuid'\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = the field 'peerL3NetworkUuid' of the vip[uuid:{0}, name:{1}, ip: {2}] has been set to {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:246
# args: self.getName(),self.getUuid(),self.getState()
the\ virtual\ router[name\:%s,\ uuid\:%s,\ current\ state\:%s]\ is\ not\ running,and\ cannot\ perform\ required\ operation.\ Please\ retry\ your\ operation\ later\ once\ it\ is\ running = the virtual router[name:{0}, uuid:{1}, current state:{2}] is not running,and cannot perform required operation. Please retry your operation later once it is running

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:251
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
virtual\ router[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = virtual router[uuid:{0}] is in status of {1} that cannot make http call to {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:173
# args: managementNetworkUuid
the\ management\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = the management network[uuid:{0}] doesn't have any IP range

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:108
# args: iso.getIsoPath(),vrSpec.getDestHost().getUuid(),vrSpec.getDestHost().getManagementIp(),iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ create\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = failed to create VirtualRouterBootstrapIso[{0}] on kvm host[uuid:{1}, ip:{2}] for virtual router[uuid:{3}], because {4}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:142
# args: iso.getIsoPath(),hostUuid,iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ delete\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = failed to delete VirtualRouterBootstrapIso[{0}] on kvm host[uuid:{1}] for virtual router[uuid:{2}], because {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:650
# args: vr.getUuid(),l3Nw.getUuid(),vr.getState()
virtual\ router[uuid\:%s]\ for\ l3\ network[uuid\:%s]\ is\ not\ in\ Running\ state,\ current\ state\ is\ %s.\ We\ don't\ have\ HA\ feature\ now(it's\ coming\ soon),\ please\ restart\ it\ from\ UI\ and\ then\ try\ starting\ this\ vm\ again = virtual router[uuid:{0}] for l3 network[uuid:{1}] is not in Running state, current state is {2}. We don't have HA feature now(it's coming soon), please restart it from UI and then try starting this vm again

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterDhcpBackend.java:120
# args: vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError(),struct
unable\ to\ add\ dhcp\ entries\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s,\ dhcp\ entry[%s] = unable to add dhcp entries to virtual router vm[uuid:{0} ip:{1}], because {2}, dhcp entry[{3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterSyncDHCPOnStartFlow.java:175
# args: vr.getUuid(),vr.getManagementNic().getIp(),ret.getError()
unable\ to\ program\ dhcp\ entries\ served\ by\ virtual\ router[uuid\:%s,\ ip\:%s],\ %s = unable to program dhcp entries served by virtual router[uuid:{0}, ip:{1}], {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterDnsBackend.java:193
# args: vr.getUuid(),vr.getManagementNic().getIp(),struct,l3.getUuid(),l3.getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ configure\ dns%s\ for\ L3Network[uuid\:%s,\ name\:%s],\ %s = virtual router[uuid:{0}, ip:{1}] failed to configure dns{2} for L3Network[uuid:{3}, name:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterSyncDnsOnStartFlow.java:108
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(dns),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ configure\ dns%s,\ %s\  = virtual router[name: {0}, uuid: {1}] failed to configure dns{2}, {3} 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:149
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ create\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = failed to create eip[uuid:{0}, name:{1}, ip:{2}] for vm nic[uuid:{3}] on virtual router[uuid:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:185
# args: offering.getUuid(),l3inv.getUuid(),l3inv.getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getEip().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ EIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to EIP[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:288
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ remove\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = failed to remove eip[uuid:{0}, name:{1}, ip:{2}] for vm nic[uuid:{3}] on virtual router[uuid:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterSyncEipOnStartFlow.java:180
# args: vr.getUuid(),ret.getError()
failed\ to\ sync\ eip\ on\ virtual\ router[uuid\:%s],\ %s = failed to sync eip on virtual router[uuid:{0}], {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:701
# args: struct.getLb().getUuid()
cannot\ find\ virtual\ router\ for\ load\ balancer\ [uuid\:%s] = cannot find virtual router for load balancer [uuid:{0}]

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:73
# args: guestL3.getUuid(),guestL3.getName(),offering.getPublicNetworkUuid(),offering.getUuid(),offering.getName()
guest\ l3Network[uuid\:%s,\ name\:%s]\ needs\ SNAT\ service\ provided\ by\ virtual\ router,\ but\ public\ l3Network[uuid\:%s]\ of\ virtual\ router\ offering[uuid\:\ %s,\ name\:%s]\ is\ the\ same\ to\ this\ guest\ l3Network = guest l3Network[uuid:{0}, name:{1}] needs SNAT service provided by virtual router, but public l3Network[uuid:{2}] of virtual router offering[uuid: {3}, name:{4}] is the same to this guest l3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:124
# args: vr.getUuid(),vr.getManagementNic().getIp(),JSONObjectUtil.toJsonString(info),spec.getVmInventory().getUuid(),spec.getVmInventory().getName(),struct.getL3Network().getUuid(),struct.getL3Network().getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ apply\ snat[%s]\ for\ vm[uuid\:%s,\ name\:%s]\ on\ L3Network[uuid\:%s,\ name\:%s],\ because\ %s = virtual router[uuid:{0}, ip:{1}] failed to apply snat[{2}] for vm[uuid:{3}, name:{4}] on L3Network[uuid:{5}, name:{6}], because {7}

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSyncSNATOnStartFlow.java:92
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(snatInfo),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ sync\ snat%s,\ %s = virtual router[name: {0}, uuid: {1}] failed to sync snat{2}, {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ApplyPortforwardingRuleOnVirtualRouterVmFlow.java:81
# args: to.getVipIp(),to.getPrivateIp(),to.getVipPortStart(),to.getVipPortEnd(),to.getPrivatePortStart(),to.getPrivatePortEnd(),ret.getError()
failed\ to\ create\ port\ forwarding\ rule[vip\ ip\:\ %s,\ private\ ip\:\ %s,\ vip\ start\ port\:\ %s,\ vip\ end\ port\:\ %s,\ private\ start\ port\:\ %s,\ private\ end\ port\:\ %s],\ because\ %s = failed to create port forwarding rule[vip ip: {0}, private ip: {1}, vip start port: {2}, vip end port: {3}, private start port: {4}, private end port: {5}], because {6}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ReleasePortForwardingRuleOnVirtualRouterVmFlow.java:75
# args: JSONObjectUtil.toJsonString(to),ret.getError()
failed\ to\ revoke\ port\ forwarding\ rules\ %s,\ because\ %s = failed to revoke port forwarding rules {0}, because {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:141
# args: offering.getUuid(),struct.getGuestL3Network().getUuid(),struct.getGuestL3Network().getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getRule().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ PortForwarding\ rule[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to PortForwarding rule[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:207
# args: rule.getVipPortStart(),rule.getVipPortEnd(),rule.getPrivatePortStart(),rule.getPrivatePortEnd()
virtual\ router\ doesn't\ support\ port\ forwarding\ range\ redirection,\ the\ vipPortStart\ must\ be\ equals\ to\ privatePortStart\ and\ vipPortEnd\ must\ be\ equals\ to\ privatePortEnd;but\ this\ rule\ rule\ has\ a\ mismatching\ range\:\ vip\ port[%s,\ %s],\ private\ port[%s,\ %s] = virtual router doesn't support port forwarding range redirection, the vipPortStart must be equals to privatePortStart and vipPortEnd must be equals to privatePortEnd;but this rule rule has a mismatching range: vip port[{0}, {1}], private port[{2}, {3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterSyncPortForwardingRulesOnStartFlow.java:187
# args: vr.getName(),vr.getUuid(),ret.getError()
failed\ to\ sync\ port\ forwarding\ rules\ served\ by\ virtual\ router[name\:\ %s,\ uuid\:\ %s],\ because\ %s = failed to sync port forwarding rules served by virtual router[name: {0}, uuid: {1}], because {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:171
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running,\ current\ HA\ has\ not\ been\ supported,\ please\ manually\ start\ this\ virtual\ router = virtual router[uuid:{0}, state:{1}] is not running, current HA has not been supported, please manually start this virtual router

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:176
# args: tos,vr.getUuid(),ret.getError()
failed\ to\ create\ vip%s\ on\ virtual\ router[uuid\:%s],\ because\ %s = failed to create vip{0} on virtual router[uuid:{1}], because {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:141
# args: tos,ret.getError()
failed\ to\ remove\ vip%s,\ because\ %s = failed to remove vip{0}, because {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:228
# args: offering.getUuid(),s.getL3Network().getUuid(),s.getL3Network().getZoneUuid(),self.getL3NetworkUuid(),self.getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ VIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to VIP[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:196
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running = virtual router[uuid:{0}, state:{1}] is not running

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosDeployAgentFlow.java:87
# args: mgmtNicIp
unable\ to\ ssh\ in\ to\ the\ vyos[%s],\ the\ ssh\ port\ seems\ not\ open = unable to ssh in to the vyos[{0}], the ssh port seems not open

# at: src/main/java/org/zstack/prometheus/PrometheusManagerImpl.java:425
# args: rsp.getStatusCode(),rsp.getBody()
query\ failure;\ status\ code\:%s,%s = query failure; status code:{0},{1}

# at: src/main/java/org/zstack/prometheus/PrometheusManagerImpl.java:482
# args: ret.get("errorType"),ret.get("error")
query\ failure,\ errorType\:%s,\ error\:\ %s = query failure, errorType:{0}, error: {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:131
# args: url,e.toString()
cannot\ get\ image.\ The\ image\ url\ is\ %s.\ Exception\ is\ %s = cannot get image. The image url is {0}. Exception is {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:139
# args: self.getUuid(),self.getName(),url,size,self.getAvailableCapacity()
the\ backup\ storage[uuid\:%s,\ name\:%s]\ has\ not\ enough\ capacity\ to\ download\ the\ image[%s].Required\ size\:%s,\ available\ size\:%s = the backup storage[uuid:{0}, name:{1}] has not enough capacity to download the image[{2}].Required size:{3}, available size:{4}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:154
# args: msg.getClass().getName(),self.getStatus()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ status\ is\ %s = backup storage cannot proceed message[{0}] because its status is {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:160
# args: msg.getClass().getName(),self.getState()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ state\ is\ %s = backup storage cannot proceed message[{0}] because its state is {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageCapacityUpdater.java:139
# args: size,backupStorageUuid,capacityVO.getAvailableCapacity()
cannot\ reserve\ %s\ on\ the\ backup\ storage[uuid\:%s],\ it\ only\ has\ %s\ available = cannot reserve {0} on the backup storage[uuid:{1}], it only has {2} available

# at: src/main/java/org/zstack/storage/backup/BackupStorageManagerImpl.java:302
# args: 
capacity\ reservation\ on\ all\ backup\ storage\ failed = capacity reservation on all backup storage failed

# at: src/main/java/org/zstack/storage/backup/BackupStorageReservedCapacityAllocatorFlow.java:46
# args: BackupStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ no\ backup\ storage\ has\ required\ capacity[%s\ bytes] = after subtracting reserved capacity[{0}], no backup storage has required capacity[{1} bytes]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:154
# args: url,rsp.getError()
unable\ to\ connect\ to\ SimpleHttpBackupStorage[url\:%s],\ because\ %s = unable to connect to SimpleHttpBackupStorage[url:{0}], because {1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:638
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ imagestoreBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = the uuid of imagestoreBackupStorage agent changed[expected:{0}, actual:{1}], it's most likely the agent was manually restarted. Issue a reconnect to sync the status

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:100
# args: scheme,url
SftpBackupStorage\ doesn't\ support\ scheme[%s]\ in\ url[%s] = SftpBackupStorage doesn't support scheme[{0}] in url[{1}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:272
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ sftpBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = the uuid of sftpBackupStorage agent changed[expected:{0}, actual:{1}], it's most likely the agent was manually restarted. Issue a reconnect to sync the status

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:436
# args: self.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ backup\ storage[uuid\:%s] = all ceph mons are Disconnected in ceph backup storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:839
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ backup\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = unable to connect to the ceph backup storage[uuid:{0}]. Failed to connect all ceph mons. Errors are {1}

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:926
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ backup\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ backup\ storage = there is another CEPH backup storage[name:{0}, uuid:{1}] with the same FSID[{2}], you cannot add the same CEPH setup as two different backup storage

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageMonBase.java:88
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ backup\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = cannot update status of the ceph backup storage mon[uuid:{0}], it has been deleted.This error can be ignored

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1658
# args: path,JSONObjectUtil.toJsonString(errorCodes)
all\ mons\ failed\ to\ execute\ http\ call[%s],\ errors\ are\ %s = all mons failed to execute http call[{0}], errors are {1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2325
# args: base.getSelf().getHostname(),fsid,getSelf().getFsid()
the\ mon[ip\:%s]\ returns\ a\ fsid[%s]\ different\ from\ the\ current\ fsid[%s]\ of\ the\ cep\ cluster,are\ you\ adding\ a\ mon\ not\ belonging\ to\ current\ cluster\ mistakenly? = the mon[ip:{0}] returns a fsid[{1}] different from the current fsid[{2}] of the cep cluster,are you adding a mon not belonging to current cluster mistakenly?

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:924
# args: backupStorage.getUuid(),backupStorage.getName(),bsFsid,self.getUuid(),self.getName(),getSelf().getFsid()
the\ backup\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s]\ is\ not\ in\ the\ same\ ceph\ cluster\ with\ the\ primary\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s] = the backup storage[uuid:{0}, name:{1}, fsid:{2}] is not in the same ceph cluster with the primary storage[uuid:{3}, name:{4}, fsid:{5}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1645
# args: self.getUuid()
all\ ceph\ mons\ of\ primary\ storage[uuid\:%s]\ are\ not\ in\ Connected\ state = all ceph mons of primary storage[uuid:{0}] are not in Connected state

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1715
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ primary\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = unable to connect to the ceph primary storage[uuid:{0}]. Failed to connect all ceph mons. Errors are {1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1804
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ primary\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ primary\ storage = there is another CEPH primary storage[name:{0}, uuid:{1}] with the same FSID[{2}], you cannot add the same CEPH setup as two different primary storage

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2028
# args: self.getUuid(),self.getName(),mon.getSelf().getUuid(),res.error
the\ ceph\ primary\ storage[uuid\:%s,\ name\:%s]\ is\ down,\ as\ one\ mon[uuid\:%s]\ reports\ an\ operation\ failure[%s] = the ceph primary storage[uuid:{0}, name:{1}] is down, as one mon[uuid:{2}] reports an operation failure[{3}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2498
# args: bsType
unable\ to\ upload\ bits\ to\ the\ backup\ storage[type\:%s],\ we\ only\ support\ CEPH = unable to upload bits to the backup storage[type:{0}], we only support CEPH

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2541
# args: 
backing\ up\ snapshots\ to\ backup\ storage\ is\ a\ depreciated\ feature,\ which\ will\ be\ removed\ in\ future\ version = backing up snapshots to backup storage is a depreciated feature, which will be removed in future version

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:256
# args: vol.getPrimaryStorageUuid()
cannot\ find\ any\ Connected\ ceph\ mon\ for\ the\ primary\ storage[uuid\:%s] = cannot find any Connected ceph mon for the primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageMonBase.java:88
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ primary\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = cannot update status of the ceph primary storage mon[uuid:{0}], it has been deleted.This error can be ignored

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageAvoidAllocatorFlow.java:50
# args: spec.getAvoidPrimaryStorageUuids()
after\ removing\ primary\ storage%s\ to\ avoid,\ there\ is\ no\ candidate\ primary\ storage\ anymore = after removing primary storage{0} to avoid, there is no candidate primary storage anymore

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:426
# args: bsUuid,self.getZoneUuid(),self.getUuid()
backup\ storage[uuid\:%s]\ is\ not\ attached\ to\ zone[uuid\:%s]\ the\ primary\ storage[uuid\:%s]\ belongs\ to = backup storage[uuid:{0}] is not attached to zone[uuid:{1}] the primary storage[uuid:{2}] belongs to

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:533
# args: 
operation\ not\ supported = operation not supported

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageCapacityUpdater.java:280
# args: size,capacityVO.getUuid()
cannot\ reserve\ %s\ bytes\ on\ the\ primary\ storage[uuid\:%s],\ it's\ short\ of\ available\ capacity = cannot reserve {0} bytes on the primary storage[uuid:{1}], it's short of available capacity

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:571
# args: errs
cannot\ find\ any\ qualified\ primary\ storage,\ errors\ are\ %s = cannot find any qualified primary storage, errors are {0}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageReservedCapacityAllocatorFlow.java:48
# args: PrimaryStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ there\ is\ no\ primary\ storage\ having\ required\ size[%s\ bytes] = after subtracting reserved capacity[{0}], there is no primary storage having required size[{1} bytes]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:126
# args: uuid
cannot\ find\ primary\ storage[uuid\:%s],\ the\ uuid\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = cannot find primary storage[uuid:{0}], the uuid is specified in instance offering or disk offering

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:166
# args: tag
cannot\ find\ primary\ storage\ having\ user\ tag[%s].\ The\ user\ tag\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = cannot find primary storage having user tag[{0}]. The user tag is specified in instance offering or disk offering

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorFlow.java:85
# args: extp.getClass().getName()
PrimaryStorageTagAllocatorExtensionPoint[%s]\ returns\ zero\ primary\ storage\ candidate = PrimaryStorageTagAllocatorExtensionPoint[{0}] returns zero primary storage candidate

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:201
# args: operationSuggestion,greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
%s\ failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = {0} failed to download bits from the imagestore backup storage[hostname:{1}, path: {2}] to the local primary storage[uuid:{3}, path: {4}], {5}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:181
# args: volume.getUuid(),image.getImageUuid(),rsp.getError()
fails\ to\ create\ root\ volume[uuid\:%s]\ from\ cached\ image[path\:%s]\ because\ %s = fails to create root volume[uuid:{0}] from cached image[path:{1}] because {2}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:305
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = failed to upload bits from the local storage[uuid:{0}, path:{1}] to image store [hostname:{2}], {3}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:235
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = failed to download bits from the imagestore backup storage[hostname:{0}, path: {1}] to the local primary storage[uuid:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/imagestore/smp/KvmAgentCommandDispatcher.java:67
# args: this.primaryStorageUuid
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ mount\ point\ storage[uuid\:%s]\ are\ disconnected = cannot find any connected host to perform the operation, it seems all KVM hosts in the clusters attached with the shared mount point storage[uuid:{0}] are disconnected

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:124
# args: vol.getUuid(),vol.getVmInstanceUuid(),vmstate
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ is\ in\ state\ of\ %s,\ please\ stop\ it\ before\ migration = the volume[uuid:{0}] is the root volume of the vm[uuid:{1}]. Currently the vm is in state of {2}, please stop it before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:133
# args: vol.getUuid(),vol.getVmInstanceUuid(),count
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ %s\ data\ volumes\ attached,\ please\ detach\ them\ before\ migration = the volume[uuid:{0}] is the root volume of the vm[uuid:{1}]. Currently the vm still has {2} data volumes attached, please detach them before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:210
# args: msg.getPrimaryStorageUuid()
The\ primary\ storage[uuid\:%s]\ is\ disabled\ cold\ migrate\ is\ not\ allowed = The primary storage[uuid:{0}] is disabled cold migrate is not allowed

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:274
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ not\ on\ the\ local\ storage\ anymore,it\ may\ have\ been\ deleted = volume[uuid:{0}] is not on the local storage anymore,it may have been deleted

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:778
# args: msg.getImage().getUuid(),self.getUuid(),JSONObjectUtil.toJsonString(ret.errorCodes)
failed\ to\ download\ image[uuid\:%s]\ to\ all\ hosts\ in\ the\ local\ storage[uuid\:%s].\ %s = failed to download image[uuid:{0}] to all hosts in the local storage[uuid:{1}]. {2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1296
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ local\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = host[uuid: {0}] of local primary storage[uuid: {1}] doesn't have enough capacity[current: {2} bytes, needed: {3}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1556
# args: msg.getVolumeUuid(),self.getUuid()
unable\ to\ create\ the\ data\ volume[uuid\:\ %s]\ on\ a\ local\ primary\ storage[uuid\:%s],\ because\ the\ hostUuid\ is\ not\ specified. = unable to create the data volume[uuid: {0}] on a local primary storage[uuid:{1}], because the hostUuid is not specified.

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:334
# args: spec.getVmInventory().getHypervisorType()
local\ storage\ doesn't\ support\ live\ migration\ for\ hypervisor[%s] = local storage doesn't support live migration for hypervisor[{0}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:510
# args: volume.getUuid(),vm.getUuid(),vm.getRootVolumeUuid(),rootHost,volume.getUuid(),dataHost
cannot\ attach\ the\ data\ volume[uuid\:%s]\ to\ the\ vm[uuid\:%s].\ Both\ vm's\ root\ volume\ and\ the\ data\ volume\ are\ on\ local\ primary\ storage,\ but\ they\ are\ on\ different\ hosts.\ The\ root\ volume[uuid\:%s]\ is\ on\ the\ host[uuid\:%s]\ but\ the\ data\ volume[uuid\:\ %s]\ is\ on\ the\ host[uuid\:\ %s] = cannot attach the data volume[uuid:{0}] to the vm[uuid:{1}]. Both vm's root volume and the data volume are on local primary storage, but they are on different hosts. The root volume[uuid:{2}] is on the host[uuid:{3}] but the data volume[uuid: {4}] is on the host[uuid: {5}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:716
# args: vol.getName(),vol.getUuid(),vol.getPrimaryStorageUuid()
the\ data\ volume[name\:%s,\ uuid\:%s]\ is\ on\ the\ local\ storage[uuid\:%s];\ however,the\ host\ on\ which\ the\ data\ volume\ is\ has\ been\ deleted.\ Unable\ to\ recover\ this\ volume = the data volume[name:{0}, uuid:{1}] is on the local storage[uuid:{2}]; however,the host on which the data volume is has been deleted. Unable to recover this volume

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:759
# args: vm.getUuid(),vm.getName(),psuuid
unable\ to\ recover\ the\ vm[uuid\:%s,\ name\:%s].\ The\ vm's\ root\ volume\ is\ on\ the\ local\ storage[uuid\:%s];\ however,\ the\ host\ on\ which\ the\ root\ volume\ is\ has\ been\ deleted = unable to recover the vm[uuid:{0}, name:{1}]. The vm's root volume is on the local storage[uuid:{2}]; however, the host on which the root volume is has been deleted

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:796
# args: vm.getUuid()
unable\ to\ live\ migrate\ with\ local\ storage.\ The\ vm[uuid\:%s]\ has\ volumes\ on\ local\ storage,to\ protect\ your\ data,\ please\ stop\ the\ vm\ and\ do\ the\ volume\ migration = unable to live migrate with local storage. The vm[uuid:{0}] has volumes on local storage,to protect your data, please stop the vm and do the volume migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmFactory.java:107
# args: context.getInventory().getUuid(),priUuid,reply.getError()
KVM\ host[uuid\:\ %s]\ fails\ to\ be\ added\ into\ local\ primary\ storage[uuid\:\ %s],\ %s = KVM host[uuid: {0}] fails to be added into local primary storage[uuid: {1}], {2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:202
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = failed to download bits from the SFTP backup storage[hostname:{0}, path: {1}] to the local primary storage[uuid:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:253
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:%s],\ %s = failed to upload bits from the local storage[uuid:{0}, path:{1}] to the SFTP backup storage[hostname:{2}, path:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:232
# args: vms.size(),StringUtils.join(vms, "\n")
there\ are\ %s\ running\ VMs\ on\ the\ NFS\ primary\ storage,\ please\ stop\ them\ and\ try\ again\:\
%s\
 = there are {0} running VMs on the NFS primary storage, please stop them and try again:\
{1}\


# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:247
# args: 
cannot\ find\ usable\ backend = cannot find usable backend

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:272
# args: 
no\ usable\ backend\ found = no usable backend found

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:411
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getSnapshot().getUuid(),msg.getSnapshot().getName()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s,\ name\:%s] = no host in Connected status to which nfs primary storage[uuid:{0}, name:{1}] attached found to revert volume[uuid:{2}] to snapshot[uuid:{3}, name:{4}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:441
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getRootImageUuid()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s] = no host in Connected status to which nfs primary storage[uuid:{0}, name:{1}] attached found to revert volume[uuid:{2}] to image[uuid:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:513
# args: vol.getVmInstanceUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state\ is\ %s = vm[uuid:{0}] is not Running or Stopped, current state is {1}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:560
# args: self.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ attach\ to\ any\ cluster = primary storage[uuid:{0}] doesn't attach to any cluster

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:736
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ usable\ host\ to\ create\ the\ data\ volume[uuid\:%s,\ name\:%s] = the NFS primary storage[uuid:{0}, name:{1}] cannot find any usable host to create the data volume[uuid:{2}, name:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1016
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ hosts\ in\ attached\ clusters\ to\ perform\ the\ operation = the NFS primary storage[uuid:{0}, name:{1}] cannot find hosts in attached clusters to perform the operation

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1209
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = the NFS primary storage[uuid:{0}, name:{1}] has not attached to any clusters, or no hosts in the attached clusters are connected

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:185
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = cannot find a Connected host to execute command for nfs primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:225
# args: psUuid,imageFormat
cannot\ find\ proper\ hypervisorType\ for\ primary\ storage[uuid\:%s]\ to\ handle\ image\ format\ or\ volume\ format[%s] = cannot find proper hypervisorType for primary storage[uuid:{0}] to handle image format or volume format[{1}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:206
# args: inv.getUuid(),inv.getName(),clusterUuid,versionInCluster,otherVersion,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage[uuid\:%s,\ name\:%s]\ to\ cluster[uuid\:%s].\ Kvm\ host\ in\ the\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ another\ cluster\ that\ has\ kvm\ host\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = unable to attach a primary storage[uuid:{0}, name:{1}] to cluster[uuid:{2}]. Kvm host in the cluster has qemu-img with version[{3}]; but the primary storage has attached to another cluster that has kvm host which has qemu-img with version[{4}]. qemu-img version greater than {5} is incompatible with versions less than {6}, this will causes volume snapshot operation to fail. Please avoid attaching a primary storage to clusters that have different Linux distributions, in order to prevent qemu-img version mismatch

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:502
# args: installPath,inv.getUuid(),rsp.getError()
failed\ to\ check\ existence\ of\ %s\ on\ nfs\ primary\ storage[uuid\:%s],\ %s = failed to check existence of {0} on nfs primary storage[uuid:{1}], {2}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:560
# args: context.getInventory().getUuid(),context.getInventory().getName(),mine,e.getKey(),version,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage\ to\ cluster.\ Kvm\ host[uuid\:%s,\ name\:%s]\ in\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ a\ cluster\ that\ has\ kvm\ host[uuid\:%s],\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = unable to attach a primary storage to cluster. Kvm host[uuid:{0}, name:{1}] in cluster has qemu-img with version[{2}]; but the primary storage has attached to a cluster that has kvm host[uuid:{3}], which has qemu-img with version[{4}]. qemu-img version greater than {5} is incompatible with versions less than {6}, this will causes volume snapshot operation to fail. Please avoid attaching a primary storage to clusters that have different Linux distributions, in order to prevent qemu-img version mismatch

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:607
# args: volume.getUuid(),volume.getName(),host.getUuid(),host.getManagementIp(),rsp.getError()
unable\ to\ create\ empty\ volume[uuid\:%s,\ \ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = unable to create empty volume[uuid:{0},  name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:723
# args: vol.getUuid(),sinv.getUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = failed to revert volume[uuid:{0}] to snapshot[uuid:{1}] on kvm host[uuid:{2}, ip:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:756
# args: vol.getUuid(),vol.getRootImageUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = failed to revert volume[uuid:{0}] to image[uuid:{1}] on kvm host[uuid:{2}, ip:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:961
# args: errors
%s = {0}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:159
# args: backupStorageInstallPath,greply.getHostname(),pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download[%s]\ from\ SftpBackupStorage[hostname\:%s]\ to\ nfs\ primary\ storage[uuid\:%s,\ path\:%s],\ %s = failed to download[{0}] from SftpBackupStorage[hostname:{1}] to nfs primary storage[uuid:{2}, path:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:216
# args: pinv.getUuid(),primaryStorageInstallPath,hostname,backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ nfs\ primary\ storage[uuid\:%s,\ path\:%s]\ to\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s],\ %s = failed to upload bits from nfs primary storage[uuid:{0}, path:{1}] to SFTP backup storage[hostname:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:979
# args: img.getUuid(),img.getName(),self.getZoneUuid()
the\ image[uuid\:%s,\ name\:\ %s]\ is\ not\ available\ to\ download\ on\ any\ backup\ storage\:\
1.\ check\ if\ image\ is\ in\ status\ of\ Deleted\
2.\ check\ if\ the\ backup\ storage\ on\ which\ the\ image\ is\ shown\ as\ Ready\ is\ attached\ to\ the\ zone[uuid\:%s] = the image[uuid:{0}, name: {1}] is not available to download on any backup storage:\
1. check if image is in status of Deleted\
2. check if the backup storage on which the image is shown as Ready is attached to the zone[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:206
# args: clusterUuid
no\ connected\ host\ found\ in\ the\ cluster[uuid\:%s] = no connected host found in the cluster[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:641
# args: 
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation = cannot find any connected host to perform the operation

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:926
# args: volume.getUuid(),volume.getVmInstanceUuid(),state
the\ volume[uuid;%s]\ is\ attached\ to\ a\ VM[uuid\:%s]\ which\ is\ in\ state\ of\ %s,\ cannot\ do\ the\ snapshot\ merge = the volume[uuid;{0}] is attached to a VM[uuid:{1}] which is in state of {2}, cannot do the snapshot merge

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1298
# args: backupStorageUuid
cannot\ find\ backup\ storage[uuid\:%s] = cannot find backup storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:87
# args: self.getUuid(),self.getName()
the\ shared\ mount\ point\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = the shared mount point primary storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for instantiating the volume

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:326
# args: 
not\ supported\ operation = not supported operation

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:312
# args: primaryStorageUuid,vol.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ support\ volume\ snapshot;\ cannot\ create\ snapshot\ for\ volume[uuid\:%s] = primary storage[uuid:{0}] doesn't support volume snapshot; cannot create snapshot for volume[uuid:{1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:132
# args: currentRoot.getUuid(),currentRoot.getName()
cannot\ find\ volume\ snapshot[uuid\:%s,\ name\:%s],\ it\ may\ have\ been\ deleted\ by\ previous\ operation = cannot find volume snapshot[uuid:{0}, name:{1}], it may have been deleted by previous operation

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:1210
# args: rmsg.getVolume().getUuid(),rmsg.getSnapshot().getUuid(),rmsg.getVolume().getVmInstanceUuid(),state
unable\ to\ reset\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s],\ the\ vm[uuid\:%s]\ volume\ attached\ to\ is\ not\ in\ Stopped\ state,\ current\ state\ is\ %s = unable to reset volume[uuid:{0}] to snapshot[uuid:{1}], the vm[uuid:{2}] volume attached to is not in Stopped state, current state is {3}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:87
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ deleted.\ This\ is\ operation\ is\ to\ recover\ a\ deleted\ data\ volume = the volume[uuid:{0}] is not in status of deleted. This is operation is to recover a deleted data volume

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:183
# args: vol.getUuid()
the\ volume[uuid\:%s]\ is\ in\ status\ of\ deleted,\ cannot\ do\ the\ operation = the volume[uuid:{0}] is in status of deleted, cannot do the operation

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:111
# args: img.getUuid(),img.getState()
image[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = image[uuid:{0}] is not Enabled, it's {1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:115
# args: img.getUuid(),img.getStatus()
image[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = image[uuid:{0}] is not Ready, it's {1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:165
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ detach\ it = the volume[uuid:{0}, name:{1}] is Root Volume, can't detach it

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:174
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ attach\ it = the volume[uuid:{0}, name:{1}] is Root Volume, can't attach it

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:179
# args: vol.getUuid()
data\ volume[uuid\:%s]\ is\ Disabled,\ can't\ attach = data volume[uuid:{0}] is Disabled, can't attach

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:225
# args: hvType,maxDataVolumeNum,count,msg.getVmInstanceUuid()
hypervisor[%s]\ only\ allows\ max\ %s\ data\ volumes\ to\ be\ attached\ to\ a\ single\ vm;\ there\ have\ been\ %s\ data\ volumes\ attached\ to\ vm[uuid\:%s] = hypervisor[{0}] only allows max {1} data volumes to be attached to a single vm; there have been {2} data volumes attached to vm[uuid:{3}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:260
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ already\ in\ status\ of\ deleted = volume[uuid:{0}] is already in status of deleted

# at: src/main/java/org/zstack/storage/volume/VolumeBase.java:450
# args: self.getUuid(),self.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ yet,\ can't\ expunge\ it = the volume[uuid:{0}, name:{1}] is not deleted yet, can't expunge it

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:325
# args: template.getUuid(),template.getName()
the\ image[uuid\:%s,\ name\:%s]\ has\ been\ deleted\ on\ all\ backup\ storage = the image[uuid:{0}, name:{1}] has been deleted on all backup storage

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:337
# args: template.getUuid(),msg.getPrimaryStorageUuid()
cannot\ find\ a\ backup\ storage\ on\ which\ the\ image[uuid\:%s]\ is\ that\ satisfies\ all\ conditions\ of\:\ 1.\ has\ state\ Enabled\ 2.\ has\ status\ Connected.\ 3\ has\ attached\ to\ zone\ in\ which\ primary\ storage[uuid\:%s]\ is = cannot find a backup storage on which the image[uuid:{0}] is that satisfies all conditions of: 1. has state Enabled 2. has status Connected. 3 has attached to zone in which primary storage[uuid:{1}] is

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:590
# args: VolumeFactory.class.getSimpleName()
there\ should\ not\ be\ more\ than\ one\ %s\ implementation. = there should not be more than one {0} implementation.

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:77
# args: msg.getUuid()
tag[uuid\:%s]\ is\ an\ inherent\ system\ tag,\ can\ not\ be\ removed = tag[uuid:{0}] is an inherent system tag, can not be removed

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:199
# args: tag,type,resourceType,resourceUuid
Duplicated\ Tag[tag\:%s,\ type\:%s,\ resourceType\:%s,\ resourceUuid\:%s] = Duplicated Tag[tag:{0}, type:{1}, resourceType:{2}, resourceUuid:{3}]